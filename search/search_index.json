{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"effectpy","text":"<p>{ width=200 }</p>"},{"location":"#effectpy","title":"effectpy","text":"<p>Effect-inspired structured async for Python.</p> <ul> <li>Structured effects with typed failure channel and rich Cause trees</li> <li>Resource safety with Layer + Scope</li> <li>Deterministic fibers over asyncio (and optional AnyIO)</li> <li>Channels, Streams, and Pipelines</li> <li>Observability: logging, metrics, tracing, OTLP exporters</li> </ul> <p>See Quick Start to jump in, or explore Concepts and API Reference.</p>"},{"location":"installation/","title":"Installation","text":"<p>Prereqs: Python 3.10+</p> <p>Options:</p> <ul> <li>Pip (latest):</li> </ul> <p><code>bash   pip install effectpy</code></p> <ul> <li>Editable from source (dev):</li> </ul> <p><code>bash   uv pip install -e .</code></p> <ul> <li> <p>Optional extras:</p> </li> <li> <p><code>anyio</code>: AnyIO runtime example</p> </li> <li><code>exporters</code>: aiohttp-based OTLP exporters</li> <li><code>docs</code>: MkDocs + Material + mkdocstrings</li> </ul> <p><code>bash   uv pip install -e .[docs]</code></p>"},{"location":"quickstart/","title":"Quick Start","text":"<pre><code>import asyncio\nfrom effectpy import *\n\nasync def main():\n  base = Context()\n  scope = Scope()\n  env = await (LoggerLayer | MetricsLayer | TracerLayer).build_scoped(base, scope)\n\n  compute = succeed(2).map(lambda x: x + 3).flat_map(lambda y: succeed(y * 2))\n  run = instrument(\"compute.demo\", compute, tags={\"component\": \"docs\"})\n  v = await run._run(env)\n  print(\"value:\", v)\n\n  await scope.close()\n\nasyncio.run(main())\n</code></pre> <p>Next: read about Effects and Layers &amp; Scope.</p>"},{"location":"concepts/effects/","title":"Effects","text":"<p>An <code>Effect[R, E, A]</code> describes an async computation that may fail with <code>E</code> and succeed with <code>A</code>. <code>R</code> is the environment type (services available in <code>Context</code>).</p> <ul> <li>Map/flat_map for composition</li> <li>Error channel via <code>Failure</code> and <code>catch_all</code></li> <li>Resource safety with <code>acquire_release</code>, <code>ensuring</code>, <code>provide</code> / <code>provide_scoped</code></li> <li>Timeouts, annotations, retry/repeat with <code>Schedule</code></li> </ul> <p>See the core API for all combinators.</p>"},{"location":"concepts/layers_scope/","title":"Layers &amp; Scope","text":"<p><code>Layer</code> acquires services into a <code>Context</code>, and <code>Scope</code> guarantees LIFO teardown.</p> <ul> <li>Compose sequentially with <code>+</code>, in parallel with <code>|</code></li> <li>Build with <code>build</code>, <code>build_scoped</code> and <code>provide</code>/<code>provide_scoped</code></li> </ul> <pre><code>env = await (LoggerLayer | MetricsLayer | TracerLayer).build_scoped(Context(), Scope())\n</code></pre>"},{"location":"concepts/observability/","title":"Observability","text":"<p><code>instrument(name, eff, tags=...)</code> captures logs, metrics, traces.</p> <ul> <li>Logger: structured JSON or plain text with levels and correlation ids</li> <li>Metrics: counters/gauges/histograms (with labels)</li> <li>Tracer: spans with attributes/events/links; simple OTLP exporters</li> </ul> <p>Exporters use <code>aiohttp</code> when installed; otherwise no-op.</p>"},{"location":"concepts/runtime_fibers/","title":"Runtime &amp; Fibers","text":"<p><code>Runtime</code> runs effects against a base <code>Context</code>, and <code>Fiber</code> represents a forked effect.</p> <ul> <li><code>fork</code> returns a <code>Fiber</code> with <code>await_</code>, <code>join</code>, <code>interrupt</code></li> <li>Supervisor hooks: start/end/failure</li> <li>AnyIO variant: <code>AnyIORuntime</code> (optional)</li> </ul>"},{"location":"concepts/streams_channels/","title":"Streams &amp; Channels","text":"<ul> <li><code>Channel</code> provides backpressured queues</li> <li><code>Stream</code> builds pipelines over <code>Queue</code></li> <li><code>StreamE</code> adds an error channel and <code>Sink</code> API</li> <li><code>Pipeline</code> is built on <code>StreamE</code></li> </ul> <p>See the stream API for details.</p>"},{"location":"guides/concurrency/","title":"Concurrency","text":"<p>Parallel combinators:</p> <ul> <li><code>zip_par(e1, e2)</code></li> <li><code>race(e1, e2)</code>; <code>race_first([...])</code>, <code>race_all([...])</code></li> <li><code>merge_all([...], parallelism=...)</code></li> <li><code>for_each_par(items, f, parallelism)</code></li> </ul> <p>All combinators cancel pending work on failure to ensure prompt interruption.</p>"},{"location":"guides/retry_schedules/","title":"Retry &amp; Schedules","text":"<p>Use <code>Schedule</code> to control retries and repeats.</p> <pre><code>eff.retry(Schedule.recurs(3))\neff.retry(Schedule.exponential(0.1).jittered())\neff.repeat(Schedule.spaced(0.5))\n</code></pre> <p>See <code>effectpy.schedule</code> for available schedules.</p>"},{"location":"guides/services_env/","title":"Services &amp; Environment","text":"<p>Fetch services with accessors and provide constants with helper layers:</p> <pre><code>from effectpy import service, provide_service\n\nclass Foo: pass\nL = provide_service(Foo, Foo())\nval = await service(Foo)._run(env)\n</code></pre> <p>Combine with <code>Layer</code> composition for complex environments.</p>"},{"location":"reference/context_scope/","title":"context &amp; scope","text":""},{"location":"reference/context_scope/#effectpy.context","title":"<code>effectpy.context</code>","text":""},{"location":"reference/context_scope/#effectpy.scope","title":"<code>effectpy.scope</code>","text":""},{"location":"reference/core/","title":"core","text":""},{"location":"reference/core/#effectpy.core","title":"<code>effectpy.core</code>","text":""},{"location":"reference/effectpy/","title":"effectpy (package)","text":""},{"location":"reference/effectpy/#effectpy","title":"<code>effectpy</code>","text":""},{"location":"reference/layer/","title":"layer","text":""},{"location":"reference/layer/#effectpy.layer","title":"<code>effectpy.layer</code>","text":""},{"location":"reference/observability/","title":"observability","text":""},{"location":"reference/observability/#effectpy.logger","title":"<code>effectpy.logger</code>","text":""},{"location":"reference/observability/#effectpy.metrics","title":"<code>effectpy.metrics</code>","text":""},{"location":"reference/observability/#effectpy.tracer","title":"<code>effectpy.tracer</code>","text":""},{"location":"reference/observability/#effectpy.exporters","title":"<code>effectpy.exporters</code>","text":""},{"location":"reference/runtime/","title":"runtime","text":""},{"location":"reference/runtime/#effectpy.runtime","title":"<code>effectpy.runtime</code>","text":""},{"location":"reference/stream/","title":"stream","text":""},{"location":"reference/stream/#effectpy.stream","title":"<code>effectpy.stream</code>","text":""},{"location":"reference/stream/#effectpy.stream.Stream","title":"<code>Stream</code>","text":"<p>               Bases: <code>Generic[A]</code></p> <p>Minimal stream built atop Queue with termination propagation.</p> <p>A Stream is a function that, given an output Queue, runs producers/tasks that write to it and then closes it when done.</p>"}]}